<!DOCTYPE html>
<html>
<head>
    <title>Optimized Boxhead Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            text-align: center;
            background-color: #222;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            margin: 0 auto;
            width: 800px;
            height: 600px;
        }
        canvas {
            display: block;
            background-color: #333;
            border: 2px solid #555;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #minimapCanvas {
            position: absolute;
            bottom: 10px;
            right: 10px;
            border: 1px solid #555;
            background-color: rgba(0, 0, 0, 0.5);
        }
        #hud {
            margin: 10px 0;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin: 0 auto 10px auto;
        }
        .hud-section {
            display: flex;
            align-items: center;
        }
        .hud-value {
            margin-left: 5px;
            font-weight: bold;
        }
        .hud-bar {
            width: 100px;
            height: 10px;
            background-color: #444;
            border-radius: 5px;
            margin-left: 5px;
            overflow: hidden;
        }
        .hud-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }
        #health-bar-fill {
            background-color: #2ecc71;
        }
        #xp-bar-fill {
            background-color: #3498db;
        }
        #ammo-bar-fill {
            background-color: #f1c40f;
        }
        #start-button, #restart-button, #continue-button {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.2s;
        }
        #start-button:hover, #restart-button:hover, #continue-button:hover {
            background-color: #c0392b;
        }
        #game-over, #wave-announcement, #level-up {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
        }
        #wave-announcement {
            font-size: 32px;
            color: #f1c40f;
            padding: 30px 60px;
        }
        #level-up h2 {
            color: #2ecc71;
        }
        .upgrade-option {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background-color: #34495e;
            border-radius: 5px;
            cursor: pointer;
        }
        .upgrade-option:hover {
            background-color: #2c3e50;
        }
        .upgrade-option button {
            background-color: #3498db;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .upgrade-option button:hover {
            background-color: #2980b9;
        }
        #coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #aaa;
        }
        .weapon-slot {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #444;
            margin-right: 5px;
            border-radius: 3px;
            text-align: center;
            line-height: 20px;
            font-size: 14px;
        }
        .weapon-active {
            background-color: #e74c3c;
        }
        #menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        #menu-container h1 {
            color: #e74c3c;
            font-size: 36px;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div id="menu-container">
        <h1>BOXHEAD</h1>
        <button id="start-button">New Game</button>
        <div id="continue-button-container" style="display:none">
            <button id="continue-button">Continue</button>
        </div>
    </div>

    <div id="hud">
        <div class="hud-section">
            Score: <span id="score" class="hud-value">0</span>
        </div>
        <div class="hud-section">
            Health: 
            <div class="hud-bar">
                <div id="health-bar-fill" class="hud-bar-fill" style="width: 100%"></div>
            </div>
            <span id="health" class="hud-value">100</span>
        </div>
        <div class="hud-section">
            Wave: <span id="wave" class="hud-value">1</span>
        </div>
        <div class="hud-section">
            Weapon: <span id="weapon" class="hud-value">Pistol</span>
            <span id="ammo" class="hud-value"></span>
        </div>
        <div class="hud-section">
            Level: <span id="level" class="hud-value">1</span>
            <div class="hud-bar">
                <div id="xp-bar-fill" class="hud-bar-fill" style="width: 0%"></div>
            </div>
        </div>
    </div>
    
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <canvas id="minimapCanvas" width="150" height="150"></canvas>
        <div id="coordinates">X: <span id="player-x">0</span> Y: <span id="player-y">0</span></div>
        
        <div id="game-over">
            <h2>GAME OVER</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <p>Waves Survived: <span id="final-wave">0</span></p>
            <button id="restart-button">Play Again</button>
        </div>
        
        <div id="wave-announcement">
            <h2>WAVE <span id="wave-number">1</span></h2>
        </div>
        
        <div id="level-up">
            <h2>LEVEL UP!</h2>
            <p>You reached level <span id="new-level">2</span>!</p>
            <p>Choose an upgrade:</p>
            <div id="upgrade-options">
                <div class="upgrade-option" data-upgrade="health">
                    <span>Max Health +20</span>
                    <button>Select</button>
                </div>
                <div class="upgrade-option" data-upgrade="speed">
                    <span>Speed +10%</span>
                    <button>Select</button>
                </div>
                <div class="upgrade-option" data-upgrade="damage">
                    <span>Damage +15%</span>
                    <button>Select</button>
                </div>
                <div class="upgrade-option" data-upgrade="fireRate">
                    <span>Fire Rate +10%</span>
                    <button>Select</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // BoxheadGame module
        const BoxheadGame = (function() {
            // Private variables and configuration
            let canvas, ctx, minimapCanvas, minimapCtx;
            let gameRunning = false;
            let score = 0;
            let currentWave = 1;
            let enemiesRemaining = 0;
            let lastFrameTime = 0;
            let deltaTime = 0;
            let gamePaused = false;
            
            // Configuration constants
            const CONFIG = {
                WORLD_WIDTH: 3000,
                WORLD_HEIGHT: 2400,
                ENEMY_SPAWN_DISTANCE: 800,
                POWERUP_DROP_CHANCE: 0.2,
                FPS_CAP: 60
            };
            
            // Game objects
            const player = {
                x: CONFIG.WORLD_WIDTH / 2,
                y: CONFIG.WORLD_HEIGHT / 2,
                width: 30,
                height: 30,
                speed: 4,
                baseSpeed: 4,
                health: 100,
                maxHealth: 100,
                weapon: 'Pistol',
                lastShot: 0,
                ammo: Infinity,
                speedBoost: 0,
                speedBoostDuration: 0,
                damageMultiplier: 1,
                fireRateMultiplier: 1
            };
            
            const camera = {
                x: 0,
                y: 0,
                width: 800,
                height: 600,
                
                update: function(target) {
                    // Center camera on target with smooth follow
                    const targetX = target.x - this.width / 2;
                    const targetY = target.y - this.height / 2;
                    
                    this.x += (targetX - this.x) * 0.1;
                    this.y += (targetY - this.y) * 0.1;
                    
                    // Clamp camera to world bounds
                    this.x = Math.max(0, Math.min(CONFIG.WORLD_WIDTH - this.width, this.x));
                    this.y = Math.max(0, Math.min(CONFIG.WORLD_HEIGHT - this.height, this.y));
                }
            };
            
            // Spatial partitioning for efficient collision detection
            const grid = {
                cellSize: 100,
                cells: {},
                
                // Reset grid
                reset: function() {
                    this.cells = {};
                },
                
                // Add object to grid
                add: function(obj) {
                    const cellX = Math.floor(obj.x / this.cellSize);
                    const cellY = Math.floor(obj.y / this.cellSize);
                    const cellKey = `${cellX},${cellY}`;
                    
                    if (!this.cells[cellKey]) {
                        this.cells[cellKey] = [];
                    }
                    
                    this.cells[cellKey].push(obj);
                    obj.cellKey = cellKey;
                },
                
                // Remove object from grid
                remove: function(obj) {
                    if (obj.cellKey) {
                        const cell = this.cells[obj.cellKey];
                        if (cell) {
                            const index = cell.indexOf(obj);
                            if (index !== -1) {
                                cell.splice(index, 1);
                            }
                        }
                        obj.cellKey = null;
                    }
                },
                
                // Update object position in grid
                update: function(obj) {
                    const newCellX = Math.floor(obj.x / this.cellSize);
                    const newCellY = Math.floor(obj.y / this.cellSize);
                    const newCellKey = `${newCellX},${newCellY}`;
                    
                    if (obj.cellKey !== newCellKey) {
                        this.remove(obj);
                        this.add(obj);
                    }
                },
                
                // Get nearby objects
                getNearby: function(obj, radius) {
                    const startCellX = Math.floor((obj.x - radius) / this.cellSize);
                    const startCellY = Math.floor((obj.y - radius) / this.cellSize);
                    const endCellX = Math.floor((obj.x + radius) / this.cellSize);
                    const endCellY = Math.floor((obj.y + radius) / this.cellSize);
                    
                    const result = [];
                    
                    for (let cellX = startCellX; cellX <= endCellX; cellX++) {
                        for (let cellY = startCellY; cellY <= endCellY; cellY++) {
                            const cellKey = `${cellX},${cellY}`;
                            if (this.cells[cellKey]) {
                                result.push(...this.cells[cellKey]);
                            }
                        }
                    }
                    
                    return result;
                }
            };
            
            // Game arrays
            const enemies = [];
            const bullets = [];
            const obstacles = [];
            const powerups = [];
            const particles = [];
            
            // Weapon definitions
            const WEAPONS = {
                Pistol: {
                    damage: 25,
                    fireRate: 300,
                    bulletSpeed: 8,
                    bulletSize: 5,
                    bulletColor: 'orange',
                    ammo: Infinity,
                    sound: 'pistol'
                },
                Shotgun: {
                    damage: 15,
                    fireRate: 800,
                    bulletSpeed: 7,
                    bulletSize: 4,
                    bulletColor: 'red',
                    spread: 0.3,
                    bullets: 5,
                    ammo: 30,
                    knockback: 2,
                    sound: 'shotgun'
                },
                MachineGun: {
                    damage: 10,
                    fireRate: 100,
                    bulletSpeed: 10,
                    bulletSize: 3,
                    bulletColor: 'yellow',
                    ammo: 100,
                    sound: 'machinegun'
                },
                GrenadeLauncher: {
                    damage: 50,
                    fireRate: 1500,
                    bulletSpeed: 5,
                    bulletSize: 8,
                    bulletColor: 'green',
                    ammo: 10,
                    explosion: {
                        radius: 80,
                        damage: 40
                    },
                    sound: 'grenade'
                }
            };
            
            // Enemy types
            const ENEMY_TYPES = {
                normal: {
                    width: 25,
                    height: 25,
                    health: 50,
                    speed: 1.5,
                    damage: 0.5,
                    color: 'green',
                    points: 10
                },
                fast: {
                    width: 20,
                    height: 20,
                    health: 30,
                    speed: 2.5,
                    damage: 0.3,
                    color: 'yellow',
                    points: 15
                },
                tank: {
                    width: 35,
                    height: 35,
                    health: 100,
                    speed: 0.8,
                    damage: 1,
                    color: 'purple',
                    points: 25
                },
                boss: {
                    width: 60,
                    height: 60,
                    health: 500,
                    speed: 1.0,
                    damage: 2,
                    color: 'red',
                    points: 100
                }
            };
            
            // Player stats and progression
            const playerStats = {
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                availableUpgradePoints: 0,
                upgrades: {
                    health: 0,
                    speed: 0,
                    damage: 0,
                    fireRate: 0
                },
                
                addXP: function(amount) {
                    this.xp += amount;
                    
                    // Check for level up
                    if (this.xp >= this.xpToNextLevel) {
                        this.levelUp();
                    }
                    
                    // Update UI
                    updateHUD();
                },
                
                levelUp: function() {
                    this.level++;
                    this.xp -= this.xpToNextLevel;
                    this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
                    this.availableUpgradePoints++;
                    
                    // Apply base upgrades
                    applyPlayerUpgrades();
                    
                    // Show level up screen
                    showLevelUpScreen();
                }
            };
            
            // Audio system (placeholders)
            const audio = {
                enabled: true,
                
                play: function(sound) {
                    if (!this.enabled) return;
                    
                    // Placeholder for actual audio implementation
                    // You would implement actual sound playback here
                    console.log(`Playing sound: ${sound}`);
                },
                
                toggle: function() {
                    this.enabled = !this.enabled;
                    return this.enabled;
                }
            };
            
            // Save system
            const saveSystem = {
                save: function() {
                    const gameState = {
                        score: score,
                        currentWave: currentWave,
                        player: {
                            x: player.x,
                            y: player.y,
                            health: player.health,
                            maxHealth: player.maxHealth,
                            weapon: player.weapon,
                            ammo: player.ammo
                        },
                        playerStats: {
                            level: playerStats.level,
                            xp: playerStats.xp,
                            xpToNextLevel: playerStats.xpToNextLevel,
                            upgrades: playerStats.upgrades
                        }
                    };
                    
                    localStorage.setItem('boxheadGameSave', JSON.stringify(gameState));
                    console.log('Game saved!');
                },
                
                load: function() {
                    const savedState = localStorage.getItem('boxheadGameSave');
                    
                    if (savedState) {
                        const gameState = JSON.parse(savedState);
                        
                        // Load game state
                        score = gameState.score;
                        currentWave = gameState.currentWave;
                        
                        // Load player state
                        player.x = gameState.player.x;
                        player.y = gameState.player.y;
                        player.health = gameState.player.health;
                        player.maxHealth = gameState.player.maxHealth;
                        player.weapon = gameState.player.weapon;
                        player.ammo = gameState.player.ammo;
                        
                        // Load player stats
                        playerStats.level = gameState.playerStats.level;
                        playerStats.xp = gameState.playerStats.xp;
                        playerStats.xpToNextLevel = gameState.playerStats.xpToNextLevel;
                        playerStats.upgrades = gameState.playerStats.upgrades;
                        
                        applyPlayerUpgrades();
                        
                        console.log('Game loaded!');
                        return true;
                    }
                    
                    return false;
                },
                
                hasSave: function() {
                    return localStorage.getItem('boxheadGameSave') !== null;
                },
                
                deleteSave: function() {
                    localStorage.removeItem('boxheadGameSave');
                    console.log('Save deleted!');
                }
            };
            
            // Controls
            const keys = {};
            let mouseX = 0;
            let mouseY = 0;
            let worldMouseX = 0;
            let worldMouseY = 0;
            let shooting = false;
            
            // Apply player upgrades
            function applyPlayerUpgrades() {
                player.maxHealth = 100 + (playerStats.upgrades.health * 20);
                player.baseSpeed = 4 + (playerStats.upgrades.speed * 0.4);
                player.damageMultiplier = 1 + (playerStats.upgrades.damage * 0.15);
                player.fireRateMultiplier = 1 + (playerStats.upgrades.fireRate * 0.1);
            }
            
            // Update HUD
            function updateHUD() {
                document.getElementById('score').textContent = score;
                document.getElementById('health').textContent = Math.floor(player.health);
                document.getElementById('health-bar-fill').style.width = `${(player.health / player.maxHealth) * 100}%`;
                document.getElementById('wave').textContent = currentWave;
                document.getElementById('weapon').textContent = player.weapon;
                document.getElementById('level').textContent = playerStats.level;
                document.getElementById('xp-bar-fill').style.width = `${(playerStats.xp / playerStats.xpToNextLevel) * 100}%`;
                document.getElementById('player-x').textContent = Math.floor(player.x);
                document.getElementById('player-y').textContent = Math.floor(player.y);
                
                // Update ammo display
                if (player.ammo === Infinity) {
                    document.getElementById('ammo').textContent = '∞';
                } else {
                    document.getElementById('ammo').textContent = player.ammo;
                }
                
                // Update ammo bar color based on remaining percentage
                if (player.ammo !== Infinity) {
                    const maxAmmo = WEAPONS[player.weapon].ammo;
                    const ammoPercentage = (player.ammo / maxAmmo) * 100;
                    document.getElementById('ammo-bar-fill').style.width = `${ammoPercentage}%`;
                    
                    if (ammoPercentage < 25) {
                        document.getElementById('ammo-bar-fill').style.backgroundColor = '#e74c3c';
                    } else if (ammoPercentage < 50) {
                        document.getElementById('ammo-bar-fill').style.backgroundColor = '#f39c12';
                    } else {
                        document.getElementById('ammo-bar-fill').style.backgroundColor = '#f1c40f';
                    }
                }
            }
            
            // Show level up screen
            function showLevelUpScreen() {
                gamePaused = true;
                
                document.getElementById('new-level').textContent = playerStats.level;
                document.getElementById('level-up').style.display = 'block';
                
                // Update upgrade options
                document.querySelectorAll('.upgrade-option').forEach(option => {
                    const upgradeType = option.getAttribute('data-upgrade');
                    const button = option.querySelector('button');
                    
                    button.addEventListener('click', function() {
                        // Apply upgrade
                        playerStats.upgrades[upgradeType]++;
                        playerStats.availableUpgradePoints--;
                        
                        // Apply upgrades to player
                        applyPlayerUpgrades();
                        
                        // Update HUD
                        updateHUD();
                        
                        // Hide level up screen
                        document.getElementById('level-up').style.display = 'none';
                        gamePaused = false;
                    });
                });
            }
            
            // Show wave announcement
            function showWaveAnnouncement(waveNumber) {
                document.getElementById('wave-number').textContent = waveNumber;
                document.getElementById('wave-announcement').style.display = 'block';
                
                // Hide after 2 seconds
                setTimeout(function() {
                    document.getElementById('wave-announcement').style.display = 'none';
                }, 2000);
                
                // Play sound
                audio.play('wave');
            }
            
            // Create enemy
            function createEnemy(type) {
                // Choose spawn position (outside visible area but not too far)
                let x, y;
                const spawnDistance = CONFIG.ENEMY_SPAWN_DISTANCE;
                const angle = Math.random() * Math.PI * 2; // Random angle
                
                // Calculate spawn position based on player's position
                x = player.x + Math.cos(angle) * spawnDistance;
                y = player.y + Math.sin(angle) * spawnDistance;
                
                // Make sure enemies spawn within world bounds
                x = Math.max(50, Math.min(CONFIG.WORLD_WIDTH - 50, x));
                y = Math.max(50, Math.min(CONFIG.WORLD_HEIGHT - 50, y));
                
                // Create enemy object
                const enemyType = ENEMY_TYPES[type];
                const enemy = {
                    x: x,
                    y: y,
                    width: enemyType.width,
                    height: enemyType.height,
                    health: enemyType.health,
                    maxHealth: enemyType.health,
                    speed: enemyType.speed,
                    damage: enemyType.damage,
                    color: enemyType.color,
                    points: enemyType.points,
                    type: type,
                    dashing: false,
                    dashSpeed: 0,
                    dashDuration: 0,
                    lastDecision: 0,
                    decisionCooldown: 500 + Math.random() * 1000,
                    targetX: player.x,
                    targetY: player.y
                };
                
                // Add to enemies array and grid
                enemies.push(enemy);
                grid.add(enemy);
                
                enemiesRemaining++;
            }
            
            // Create boss enemy
            function createBossEnemy() {
                const boss = {
                    x: player.x + Math.cos(Math.random() * Math.PI * 2) * CONFIG.ENEMY_SPAWN_DISTANCE,
                    y: player.y + Math.sin(Math.random() * Math.PI * 2) * CONFIG.ENEMY_SPAWN_DISTANCE,
                    width: ENEMY_TYPES.boss.width,
                    height: ENEMY_TYPES.boss.height,
                    health: ENEMY_TYPES.boss.health * currentWave/5,
                    maxHealth: ENEMY_TYPES.boss.health * currentWave/5,
                    speed: ENEMY_TYPES.boss.speed,
                    damage: ENEMY_TYPES.boss.damage,
                    color: ENEMY_TYPES.boss.color,
                    points: ENEMY_TYPES.boss.points * currentWave,
                    type: 'boss',
                    dashing: false,
                    dashSpeed: 0,
                    dashDuration: 0,
                    lastDecision: 0,
                    decisionCooldown: 500 + Math.random() * 1000,
                    targetX: player.x,
                    targetY: player.y,
                    specialAttackCooldown: 0
                };
                
                // Make sure boss spawns within world bounds
                boss.x = Math.max(50, Math.min(CONFIG.WORLD_WIDTH - 50, boss.x));
                boss.y = Math.max(50, Math.min(CONFIG.WORLD_HEIGHT - 50, boss.y));
                
                // Add to enemies array and grid
                enemies.push(boss);
                grid.add(boss);
                
                enemiesRemaining++;
                
                // Show boss announcement
                showWaveAnnouncement("BOSS " + currentWave);
                
                // Play boss sound
                audio.play('boss');
            }
            
            // Create wave
            function createWave() {
                const baseEnemies = Math.floor(3 + (currentWave * 1.5));
                enemiesRemaining = 0;
                
                // Show wave announcement
                showWaveAnnouncement(currentWave);
                
                // Determine enemy types based on wave
                let types = ['normal'];
                
                if (currentWave >= 2) types.push('fast');
                if (currentWave >= 3) types.push('tank');
                if (currentWave >= 5 && currentWave % 5 === 0) {
                    // Boss wave every 5 waves
                    createBossEnemy();
                    return;
                }
                
                // Create enemies with slight delay for better gameplay
                let enemiesCreated = 0;
                
                function spawnNextEnemy() {
                    if (enemiesCreated < baseEnemies && gameRunning) {
                        const type = types[Math.floor(Math.random() * types.length)];
                        createEnemy(type);
                        enemiesCreated++;
                        
                        // Schedule next enemy spawn
                        setTimeout(spawnNextEnemy, 200 + Math.random() * 300);
                    }
                }
                
                // Start spawning
                spawnNextEnemy();
            }
            
            // Create bullet
            function createBullet() {
                const weaponData = WEAPONS[player.weapon];
                
                // Check if player has ammo
                if (player.ammo <= 0 && player.weapon !== 'Pistol') {
                    // Out of ammo, switch to pistol
                    player.weapon = 'Pistol';
                    player.ammo = Infinity;
                    updateHUD();
                    return;
                }
                
                // Check fire rate (adjusted by player's fire rate multiplier)
                const currentTime = Date.now();
                const adjustedFireRate = weaponData.fireRate / player.fireRateMultiplier;
                
                if (currentTime - player.lastShot < adjustedFireRate) {
                    return;
                }
                
                player.lastShot = currentTime;
                
                // Decrease ammo if not infinite
                if (player.ammo !== Infinity) {
                    player.ammo--;
                    updateHUD();
                }
                
                // Calculate angle to mouse (in world coordinates)
                const dx = worldMouseX - player.x;
                const dy = worldMouseY - player.y;
                const angle = Math.atan2(dy, dx);
                
                // Play sound
                audio.play(weaponData.sound);
                
                // Create bullets based on weapon type
                if (player.weapon === 'Shotgun') {
                    // Create multiple bullets with spread
                    for (let i = 0; i < weaponData.bullets; i++) {
                        const spreadAngle = angle + (Math.random() * weaponData.spread * 2 - weaponData.spread);
                        
                        const bullet = {
                            x: player.x,
                            y: player.y,
                            width: weaponData.bulletSize,
                            height: weaponData.bulletSize,
                            angle: spreadAngle,
                            speed: weaponData.bulletSpeed,
                            damage: weaponData.damage * player.damageMultiplier,
                            color: weaponData.bulletColor,
                            knockback: weaponData.knockback || 0,
                            owner: 'player'
                        };
                        
                        bullets.push(bullet);
                        grid.add(bullet);
                    }
                } else if (player.weapon === 'GrenadeLauncher') {
                    // Create grenade bullet
                    const bullet = {
                        x: player.x,
                        y: player.y,
                        width: weaponData.bulletSize,
                        height: weaponData.bulletSize,
                        angle: angle,
                        speed: weaponData.bulletSpeed,
                        damage: weaponData.damage * player.damageMultiplier,
                        color: weaponData.bulletColor,
                        knockback: 0,
                        owner: 'player',
                        isGrenade: true,
                        explosion: weaponData.explosion,
                        timer: 30 // Explodes after 30 frames
                    };
                    
                    bullets.push(bullet);
                    grid.add(bullet);
                } else {
                    // Create single bullet
                    const bullet = {
                        x: player.x,
                        y: player.y,
                        width: weaponData.bulletSize,
                        height: weaponData.bulletSize,
                        angle: angle,
                        speed: weaponData.bulletSpeed,
                        damage: weaponData.damage * player.damageMultiplier,
                        color: weaponData.bulletColor,
                        knockback: 0,
                        owner: 'player'
                    };
                    
                    bullets.push(bullet);
                    grid.add(bullet);
                }
                
                // Create muzzle flash particle
                createMuzzleFlash(player.x, player.y, angle);
            }
            
            // Create explosion
            function createExplosion(x, y, radius, damage) {
                // Create explosion particles
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius;
                    const lifetime = 20 + Math.random() * 40;
                    
                    createParticle(
                        x + Math.cos(angle) * distance * 0.5,
                        y + Math.sin(angle) * distance * 0.5,
                        ['orange', 'red', 'yellow'][Math.floor(Math.random() * 3)],
                        3 + Math.random() * 5,
                        lifetime,
                        Math.cos(angle) * (Math.random() * 3),
                        Math.sin(angle) * (Math.random() * 3)
                    );
                }
                
                // Damage nearby enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = Math.sqrt(
                        Math.pow(enemy.x - x, 2) + 
                        Math.pow(enemy.y - y, 2)
                    );
                    
                    if (dist <= radius) {
                        // Calculate damage based on distance from explosion center
                        const damageMultiplier = 1 - (dist / radius);
                        const explosionDamage = damage * damageMultiplier;
                        
                        // Apply damage
                        enemy.health -= explosionDamage;
                        
                        // Knockback
                        const knockbackAngle = Math.atan2(enemy.y - y, enemy.x - x);
                        const knockbackForce = 10 * damageMultiplier;
                        
                        enemy.x += Math.cos(knockbackAngle) * knockbackForce;
                        enemy.y += Math.sin(knockbackAngle) * knockbackForce;
                        
                        // Check if enemy is dead
                        if (enemy.health <= 0) {
                            // Add score
                            score += enemy.points;
                            playerStats.addXP(enemy.points / 2);
                            updateHUD();
                            
                            // Chance to drop powerup
                            if (Math.random() < CONFIG.POWERUP_DROP_CHANCE) {
                                createPowerup(enemy.x, enemy.y);
                            }
                            
                            // Create death particles
                            createBloodSplatter(enemy.x, enemy.y);
                            
                            // Remove from grid
                            grid.remove(enemy);
                            
                            // Remove enemy
                            enemies.splice(i, 1);
                            enemiesRemaining--;
                            
                            // Play sound
                            audio.play('enemyDeath');
                            
                            // Check if wave is complete
                            if (enemiesRemaining <= 0) {
                                currentWave++;
                                updateHUD();
                                
                                // Auto-save game after each wave
                                saveSystem.save();
                                
                                // Slight delay before next wave
                                setTimeout(function() {
                                    createWave();
                                }, 2000);
                            }
                        }
                    }
                }
                
                // Damage player if in radius
                const playerDist = Math.sqrt(
                    Math.pow(player.x - x, 2) + 
                    Math.pow(player.y - y, 2)
                );
                
                if (playerDist <= radius) {
                    const damageMultiplier = 1 - (playerDist / radius);
                    const explosionDamage = damage * damageMultiplier * 0.5; // Reduced self-damage
                    
                    player.health -= explosionDamage;
                    updateHUD();
                    
                    // Knockback player
                    const knockbackAngle = Math.atan2(player.y - y, player.x - x);
                    const knockbackForce = 15 * damageMultiplier;
                    
                    player.x += Math.cos(knockbackAngle) * knockbackForce;
                    player.y += Math.sin(knockbackAngle) * knockbackForce;
                    
                    // Check if player is dead
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
                
                // Play sound
                audio.play('explosion');
            }
            
            // Create powerup
            function createPowerup(x, y) {
                // Types of powerups
                const types = [
                    {
                        type: 'health',
                        color: '#e74c3c',
                        effect: function() {
                            player.health = Math.min(player.maxHealth, player.health + 25);
                            audio.play('powerup');
                        }
                    },
                    {
                        type: 'weapon',
                        color: '#9b59b6',
                        effect: function() {
                            const weapons = ['Shotgun', 'MachineGun', 'GrenadeLauncher'];
                            player.weapon = weapons[Math.floor(Math.random() * weapons.length)];
                            player.ammo = WEAPONS[player.weapon].ammo;
                            audio.play('powerup');
                        }
                    },
                    {
                        type: 'speed',
                        color: '#3498db',
                        effect: function() {
                            player.speedBoost = 2;
                            player.speedBoostDuration = 600; // 10 seconds at 60fps
                            audio.play('powerup');
                        }
                    },
                    {
                        type: 'ammo',
                        color: '#f1c40f',
                        effect: function() {
                            if (player.weapon !== 'Pistol') {
                                player.ammo = Math.min(
                                    WEAPONS[player.weapon].ammo * 2,
                                    player.ammo + Math.floor(WEAPONS[player.weapon].ammo * 0.5)
                                );
                            }
                            audio.play('powerup');
                        }
                    }
                ];
                
                const powerupType = types[Math.floor(Math.random() * types.length)];
                
                const powerup = {
                    x: x,
                    y: y,
                    width: 15,
                    height: 15,
                    type: powerupType.type,
                    color: powerupType.color,
                    effect: powerupType.effect,
                    pulseSize: 0,
                    pulseDir: 1
                };
                
                powerups.push(powerup);
                grid.add(powerup);
            }
            
            // Create particle
            function createParticle(x, y, color, size, lifetime, speedX, speedY) {
                particles.push({
                    x: x,
                    y: y,
                    color: color,
                    size: size,
                    lifetime: lifetime,
                    maxLifetime: lifetime,
                    speedX: speedX,
                    speedY: speedY
                });
            }
            
            // Create blood splatter
            function createBloodSplatter(x, y) {
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.5 + Math.random() * 2;
                    createParticle(
                        x, y,
                        'darkred',
                        2 + Math.random() * 3,
                        20 + Math.random() * 30,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );
                }
            }
            
            // Create muzzle flash
            function createMuzzleFlash(x, y, angle) {
                for (let i = 0; i < 5; i++) {
                    const particleAngle = angle + (Math.random() * 0.5 - 0.25);
                    const distance = 10 + Math.random() * 10;
                    
                    createParticle(
                        x + Math.cos(angle) * distance,
                        y + Math.sin(angle) * distance,
                        ['yellow', 'orange'][Math.floor(Math.random() * 2)],
                        2 + Math.random() * 3,
                        5 + Math.random() * 5,
                        Math.cos(particleAngle) * (1 + Math.random()),
                        Math.sin(particleAngle) * (1 + Math.random())
                    );
                }
            }
            
            // Create obstacles
            function createObstacles() {
                obstacles.length = 0;
                
                // Create border walls around the world
                obstacles.push({
                    x: -50, y: -50, width: CONFIG.WORLD_WIDTH + 100, height: 50, color: '#555' // Top wall
                });
                obstacles.push({
                    x: -50, y: CONFIG.WORLD_HEIGHT, width: CONFIG.WORLD_WIDTH + 100, height: 50, color: '#555' // Bottom wall
                });
                obstacles.push({
                    x: -50, y: 0, width: 50, height: CONFIG.WORLD_HEIGHT, color: '#555' // Left wall
                });
                obstacles.push({
                    x: CONFIG.WORLD_WIDTH, y: 0, width: 50, height: CONFIG.WORLD_HEIGHT, color: '#555' // Right wall
                });
                
                // Add obstacles to grid
                for (const obstacle of obstacles) {
                    grid.add(obstacle);
                }
                
                // Create some random obstacles throughout the world
                const numObstacles = 40; // More obstacles for a larger world
                
                for (let i = 0; i < numObstacles; i++) {
                    const width = 30 + Math.floor(Math.random() * 70);
                    const height = 30 + Math.floor(Math.random() * 70);
                    
                    // Find valid position (not on player)
                    let x, y, validPosition = false;
                    
                    while (!validPosition) {
                        x = 50 + Math.random() * (CONFIG.WORLD_WIDTH - width - 100);
                        y = 50 + Math.random() * (CONFIG.WORLD_HEIGHT - height - 100);
                        
                        // Make sure obstacle is away from player
                        const distToPlayer = Math.sqrt(
                            Math.pow(x + width/2 - player.x, 2) + 
                            Math.pow(y + height/2 - player.y, 2)
                        );
                        
                        if (distToPlayer > 200) {
                            validPosition = true;
                        }
                    }
                    
                    const obstacle = {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        color: '#555'
                    };
                    
                    obstacles.push(obstacle);
                    grid.add(obstacle);
                }
            }
            
            // Check collision between two rectangles
            function checkCollision(a, b) {
                return (
                    a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y
                );
            }
            
            // Check if object is in camera view
            function isInView(obj) {
                return (
                    obj.x + obj.width > camera.x &&
                    obj.x < camera.x + camera.width &&
                    obj.y + obj.height > camera.y &&
                    obj.y < camera.y + camera.height
                );
            }
            
            // Initialize game
            function initGame() {
                // Reset game variables
                gameRunning = true;
                gamePaused = false;
                score = 0;
                currentWave = 1;
                enemiesRemaining = 0;
                
                // Reset player
                player.x = CONFIG.WORLD_WIDTH / 2;
                player.y = CONFIG.WORLD_HEIGHT / 2;
                player.health = 100;
                player.maxHealth = 100;
                player.weapon = 'Pistol';
                player.ammo = Infinity;
                player.speedBoost = 0;
                player.speedBoostDuration = 0;
                player.damageMultiplier = 1;
                player.fireRateMultiplier = 1;
                
                // Reset player stats
                playerStats.level = 1;
                playerStats.xp = 0;
                playerStats.xpToNextLevel = 100;
                playerStats.upgrades = {
                    health: 0,
                    speed: 0,
                    damage: 0,
                    fireRate: 0
                };
                
                // Reset camera
                camera.x = 0;
                camera.y = 0;
                camera.update(player);
                
                // Clear arrays
                enemies.length = 0;
                bullets.length = 0;
                powerups.length = 0;
                particles.length = 0;
                
                // Reset grid
                grid.reset();
                
                // Create obstacles
                createObstacles();
                
                // Create first wave
                createWave();
                
                // Update HUD
                updateHUD();
                
                // Hide elements
                document.getElementById('menu-container').style.display = 'none';
                document.getElementById('game-over').style.display = 'none';
                
                // Start game loop if not already running
                if (!isGameLoopRunning) {
                    isGameLoopRunning = true;
                    lastFrameTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
                
                // Play start sound
                audio.play('start');
            }
            
            // Continue game from save
            function continueGame() {
                if (saveSystem.load()) {
                    gameRunning = true;
                    gamePaused = false;
                    
                    // Reset arrays
                    enemies.length = 0;
                    bullets.length = 0;
                    powerups.length = 0;
                    particles.length = 0;
                    
                    // Reset grid
                    grid.reset();
                    
                    // Create obstacles
                    createObstacles();
                    
                    // Update camera
                    camera.update(player);
                    
                    // Update HUD
                    updateHUD();
                    
                    // Hide elements
                    document.getElementById('menu-container').style.display = 'none';
                    document.getElementById('game-over').style.display = 'none';
                    
                    // Create wave
                    createWave();
                    
                    // Start game loop if not already running
                    if (!isGameLoopRunning) {
                        isGameLoopRunning = true;
                        lastFrameTime = performance.now();
                        requestAnimationFrame(gameLoop);
                    }
                    
                    // Play continue sound
                    audio.play('continue');
                }
            }
            
            // Game over
            function gameOver() {
                gameRunning = false;
                
                // Update final score
                document.getElementById('final-score').textContent = score;
                document.getElementById('final-wave').textContent = currentWave;
                
                // Show game over screen
                document.getElementById('game-over').style.display = 'block';
                
                // Delete save
                saveSystem.deleteSave();
                
                // Play game over sound
                audio.play('gameOver');
            }
            
            // Update enemy AI
            function updateEnemy(enemy) {
                const currentTime = Date.now();
                
                // Only update decision occasionally for performance
                if (currentTime - enemy.lastDecision > enemy.decisionCooldown) {
                    enemy.lastDecision = currentTime;
                    
                    // Update target position (with some randomness)
                    const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    
                    // Different behavior for different enemy types
                    if (enemy.type === 'fast' && Math.random() < 0.2) {
                        // Fast enemy occasionally dashes directly toward player
                        enemy.dashing = true;
                        enemy.dashSpeed = enemy.speed * 3;
                        enemy.dashDuration = 20;
                        enemy.targetX = player.x;
                        enemy.targetY = player.y;
                    } else if (enemy.type === 'tank' && Math.random() < 0.3) {
                        // Tank enemy occasionally takes a more direct path
                        enemy.targetX = player.x;
                        enemy.targetY = player.y;
                    } else if (enemy.type === 'boss') {
                        // Boss has special attacks
                        if (enemy.specialAttackCooldown <= 0 && Math.random() < 0.3) {
                            // Perform special attack
                            if (Math.random() < 0.5) {
                                // Dash attack
                                enemy.dashing = true;
                                enemy.dashSpeed = enemy.speed * 4;
                                enemy.dashDuration = 30;
                                enemy.targetX = player.x;
                                enemy.targetY = player.y;
                            } else {
                                // Summon minions
                                for (let i = 0; i < 3; i++) {
                                    createEnemy('normal');
                                }
                            }
                            
                            enemy.specialAttackCooldown = 180; // 3 seconds at 60fps
                        } else {
                            // Normal movement with some randomness
                            const randomAngle = angleToPlayer + (Math.random() * 0.5 - 0.25);
                            enemy.targetX = player.x + Math.cos(randomAngle) * (50 + Math.random() * 100);
                            enemy.targetY = player.y + Math.sin(randomAngle) * (50 + Math.random() * 100);
                        }
                        
                        // Decrease special attack cooldown
                        if (enemy.specialAttackCooldown > 0) {
                            enemy.specialAttackCooldown--;
                        }
                    } else {
                        // Normal enemies move toward player with some randomness
                        const randomAngle = angleToPlayer + (Math.random() * 0.8 - 0.4);
                        enemy.targetX = player.x + Math.cos(randomAngle) * (30 + Math.random() * 50);
                        enemy.targetY = player.y + Math.sin(randomAngle) * (30 + Math.random() * 50);
                    }
                }
                
                // Move toward target
                if (enemy.dashing) {
                    // Dashing behavior - move directly toward target
                    const dx = enemy.targetX - enemy.x;
                    const dy = enemy.targetY - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        enemy.x += (dx / dist) * enemy.dashSpeed;
                        enemy.y += (dy / dist) * enemy.dashSpeed;
                    }
                    
                    // Create dash particles
                    if (Math.random() < 0.3) {
                        createParticle(
                            enemy.x, enemy.y,
                            enemy.color,
                            enemy.width / 4,
                            10,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                    }
                    
                    enemy.dashDuration--;
                    if (enemy.dashDuration <= 0) {
                        enemy.dashing = false;
                    }
                } else {
                    // Normal movement
                    const dx = enemy.targetX - enemy.x;
                    const dy = enemy.targetY - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 5) { // Only move if we're not very close to target
                        enemy.x += (dx / dist) * enemy.speed;
                        enemy.y += (dy / dist) * enemy.speed;
                    }
                }
                
                // Avoid obstacles
                const nearbyObstacles = grid.getNearby(enemy, 100);
                
                for (const obj of nearbyObstacles) {
                    if (obj === enemy || !obj.width || !obj.height) continue;
                    
                    // Only check collision with obstacles
                    if (obstacles.includes(obj)) {
                        const enemyRect = {
                            x: enemy.x - enemy.width/2,
                            y: enemy.y - enemy.height/2,
                            width: enemy.width,
                            height: enemy.height
                        };
                        
                        if (checkCollision(enemyRect, obj)) {
                            // Simple obstacle avoidance - move away from center of obstacle
                            const obstacleCenter = {
                                x: obj.x + obj.width / 2,
                                y: obj.y + obj.height / 2
                            };
                            
                            const avoidDx = enemy.x - obstacleCenter.x;
                            const avoidDy = enemy.y - obstacleCenter.y;
                            const avoidDist = Math.sqrt(avoidDx * avoidDx + avoidDy * avoidDy);
                            
                            if (avoidDist > 0) {
                                enemy.x += (avoidDx / avoidDist) * 2;
                                enemy.y += (avoidDy / avoidDist) * 2;
                            }
                        }
                    }
                }
                
                // Check collision with player
                const enemyRect = {
                    x: enemy.x - enemy.width/2,
                    y: enemy.y - enemy.height/2,
                    width: enemy.width,
                    height: enemy.height
                };
                
                const playerRect = {
                    x: player.x - player.width/2,
                    y: player.y - player.height/2,
                    width: player.width,
                    height: player.height
                };
                
                if (checkCollision(enemyRect, playerRect)) {
                    // Damage player
                    player.health -= enemy.damage;
                    updateHUD();
                    
                    // Play damage sound
                    audio.play('playerDamage');
                    
                    // Check if player is dead
                    if (player.health <= 0) {
                        gameOver();
                        return;
                    }
                    
                    // Push enemy back slightly
                    const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                    enemy.x += Math.cos(pushAngle) * 5;
                    enemy.y += Math.sin(pushAngle) * 5;
                }
                
                // Keep enemy in bounds
                enemy.x = Math.max(enemy.width/2, Math.min(CONFIG.WORLD_WIDTH - enemy.width/2, enemy.x));
                enemy.y = Math.max(enemy.height/2, Math.min(CONFIG.WORLD_HEIGHT - enemy.height/2, enemy.y));
                
                // Update enemy position in grid
                grid.update(enemy);
            }
            
            // Update game state
            function update(deltaTime) {
                if (!gameRunning || gamePaused) return;
                
                // Update player speed
                player.speed = player.baseSpeed;
                
                // Apply speed boost if active
                if (player.speedBoostDuration > 0) {
                    player.speed += player.speedBoost;
                    player.speedBoostDuration--;
                    
                    // Create speed particles
                    if (Math.random() < 0.2) {
                        createParticle(
                            player.x, player.y,
                            '#3498db',
                            player.width / 4,
                            10,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                    }
                }
                
                // Update player position based on keys
                if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                    player.y -= player.speed;
                }
                if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                    player.y += player.speed;
                }
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    player.x -= player.speed;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    player.x += player.speed;
                }
                
                // Keep player within world bounds
                player.x = Math.max(player.width/2, Math.min(CONFIG.WORLD_WIDTH - player.width/2, player.x));
                player.y = Math.max(player.height/2, Math.min(CONFIG.WORLD_HEIGHT - player.height/2, player.y));
                
                // Update camera to follow player
                camera.update(player);
                
                // Update world mouse position
                worldMouseX = mouseX + camera.x;
                worldMouseY = mouseY + camera.y;
                
                // Check obstacle collisions
                const playerRect = {
                    x: player.x - player.width/2,
                    y: player.y - player.height/2,
                    width: player.width,
                    height: player.height
                };
                
                const nearbyObstacles = grid.getNearby(player, 100);
                
                for (const obj of nearbyObstacles) {
                    if (!obstacles.includes(obj)) continue;
                    
                    if (checkCollision(playerRect, obj)) {
                        // Calculate overlap on each axis
                        const overlapX = Math.min(
                            playerRect.x + playerRect.width - obj.x,
                            obj.x + obj.width - playerRect.x
                        );
                        
                        const overlapY = Math.min(
                            playerRect.y + playerRect.height - obj.y,
                            obj.y + obj.height - playerRect.y
                        );
                        
                        // Resolve collision by moving player along the axis with smaller overlap
                        if (overlapX < overlapY) {
                            if (playerRect.x < obj.x) {
                                player.x -= overlapX;
                            } else {
                                player.x += overlapX;
                            }
                        } else {
                            if (playerRect.y < obj.y) {
                                player.y -= overlapY;
                            } else {
                                player.y += overlapY;
                            }
                        }
                    }
                }
                
                // Shoot if shooting flag is true
                if (shooting) {
                    createBullet();
                }
                
                // Update bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    
                    if (bullet.isGrenade) {
                        // Update grenade timer
                        bullet.timer--;
                        
                        if (bullet.timer <= 0) {
                            // Explode
                            createExplosion(bullet.x, bullet.y, bullet.explosion.radius, bullet.explosion.damage * player.damageMultiplier);
                            
                            // Remove bullet
                            grid.remove(bullet);
                            bullets.splice(i, 1);
                            continue;
                        }
                        
                        // Slow down grenade
                        bullet.speed *= 0.95;
                    }
                    
                    // Move bullet
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    
                    // Remove bullets out of world
                    if (
                        bullet.x < 0 ||
                        bullet.x > CONFIG.WORLD_WIDTH ||
                        bullet.y < 0 ||
                        bullet.y > CONFIG.WORLD_HEIGHT
                    ) {
                        grid.remove(bullet);
                        bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Update bullet in grid
                    grid.update(bullet);
                    
                    // Check bullet collisions with nearby objects
                    const nearbyObjects = grid.getNearby(bullet, 50);
                    let bulletRemoved = false;
                    
                    for (const obj of nearbyObjects) {
                        if (obj === bullet) continue;
                        
                        const bulletRect = {
                            x: bullet.x - bullet.width/2,
                            y: bullet.y - bullet.height/2,
                            width: bullet.width,
                            height: bullet.height
                        };
                        
                        // Check bullet-obstacle collisions
                        if (obstacles.includes(obj)) {
                            if (checkCollision(bulletRect, obj)) {
                                if (bullet.isGrenade) {
                                    // Grenades explode on impact
                                    createExplosion(bullet.x, bullet.y, bullet.explosion.radius, bullet.explosion.damage * player.damageMultiplier);
                                }
                                
                                // Remove bullet
                                grid.remove(bullet);
                                bullets.splice(i, 1);
                                bulletRemoved = true;
                                break;
                            }
                        }
                        
                        // Check bullet-enemy collisions
                        if (!bulletRemoved && enemies.includes(obj) && bullet.owner === 'player') {
                            const enemyRect = {
                                x: obj.x - obj.width/2,
                                y: obj.y - obj.height/2,
                                width: obj.width,
                                height: obj.height
                            };
                            
                            if (checkCollision(bulletRect, enemyRect)) {
                                const enemy = obj;
                                
                                if (bullet.isGrenade) {
                                    // Grenades explode on impact
                                    createExplosion(bullet.x, bullet.y, bullet.explosion.radius, bullet.explosion.damage * player.damageMultiplier);
                                    grid.remove(bullet);
                                    bullets.splice(i, 1);
                                    bulletRemoved = true;
                                    break;
                                }
                                
                                // Damage enemy
                                enemy.health -= bullet.damage;
                                
                                // Knockback
                                if (bullet.knockback > 0) {
                                    const knockbackAngle = bullet.angle;
                                    enemy.x += Math.cos(knockbackAngle) * bullet.knockback;
                                    enemy.y += Math.sin(knockbackAngle) * bullet.knockback;
                                }
                                
                                // Create blood particles
                                createBloodSplatter(bullet.x, bullet.y);
                                
                                // Remove bullet
                                grid.remove(bullet);
                                bullets.splice(i, 1);
                                bulletRemoved = true;
                                
                                // Check if enemy is dead
                                if (enemy.health <= 0) {
                                    // Add score
                                    score += enemy.points;
                                    playerStats.addXP(enemy.points / 2);
                                    updateHUD();
                                    
                                    // Chance to drop powerup
                                    if (Math.random() < CONFIG.POWERUP_DROP_CHANCE) {
                                        createPowerup(enemy.x, enemy.y);
                                    }
                                    
                                    // Create death particles
                                    createBloodSplatter(enemy.x, enemy.y);
                                    
                                    // Remove from grid
                                    grid.remove(enemy);
                                    
                                    // Remove enemy
                                    const enemyIndex = enemies.indexOf(enemy);
                                    if (enemyIndex !== -1) {
                                        enemies.splice(enemyIndex, 1);
                                        enemiesRemaining--;
                                    }
                                    
                                    // Play sound
                                    audio.play('enemyDeath');
                                    
                                    // Check if wave is complete
                                    if (enemiesRemaining <= 0) {
                                        currentWave++;
                                        updateHUD();
                                        
                                        // Auto-save game after each wave
                                        saveSystem.save();
                                        
                                        // Slight delay before next wave
                                        setTimeout(function() {
                                            createWave();
                                        }, 2000);
                                    }
                                }
                                
                                break;
                            }
                        }
                    }
                }
                
                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    
                    // Only process enemies that are somewhat close to the player
                    const distToPlayer = Math.sqrt(
                        Math.pow(enemy.x - player.x, 2) + 
                        Math.pow(enemy.y - player.y, 2)
                    );
                    
                    // Skip enemies that are very far away to save processing
                    if (distToPlayer > 1000) continue;
                    
                    // Update enemy AI
                    updateEnemy(enemy);
                }
                
                // Update powerups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const powerup = powerups[i];
                    
                    // Update pulse animation
                    powerup.pulseSize += powerup.pulseDir * 0.03;
                    
                    if (powerup.pulseSize > 1.5) {
                        powerup.pulseSize = 1.5;
                        powerup.pulseDir = -1;
                    } else if (powerup.pulseSize < 0.7) {
                        powerup.pulseSize = 0.7;
                        powerup.pulseDir = 1;
                    }
                    
                    // Check collision with player
                    const powerupRect = {
                        x: powerup.x - powerup.width/2,
                        y: powerup.y - powerup.height/2,
                        width: powerup.width,
                        height: powerup.height
                    };
                    
                    if (checkCollision(playerRect, powerupRect)) {
                        // Apply powerup
                        powerup.effect();
                        updateHUD();
                        
                        // Create pickup particles
                        for (let j = 0; j < 10; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            createParticle(
                                powerup.x, powerup.y,
                                powerup.color,
                                3 + Math.random() * 2,
                                20 + Math.random() * 10,
                                Math.cos(angle) * (1 + Math.random()),
                                Math.sin(angle) * (1 + Math.random())
                            );
                        }
                        
                        // Remove from grid
                        grid.remove(powerup);
                        
                        // Remove powerup
                        powerups.splice(i, 1);
                    }
                }
                
                // Update particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    
                    // Update position
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    
                    // Slow down
                    particle.speedX *= 0.96;
                    particle.speedY *= 0.96;
                    
                    // Update lifetime
                    particle.lifetime--;
                    
                    // Remove dead particles
                    if (particle.lifetime <= 0) {
                        particles.splice(i, 1);
                    }
                }
                
                // Update coordinates display
                updateHUD();
            }
            
            // Render game
            function render() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid background for world
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                
                // Draw vertical grid lines
                for (let x = Math.floor(camera.x / 100) * 100; x < camera.x + camera.width; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x - camera.x, 0);
                    ctx.lineTo(x - camera.x, canvas.height);
                    ctx.stroke();
                }
                
                // Draw horizontal grid lines
                for (let y = Math.floor(camera.y / 100) * 100; y < camera.y + camera.height; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(0, y - camera.y);
                    ctx.lineTo(canvas.width, y - camera.y);
                    ctx.stroke();
                }
                
                // Draw obstacles (only those in view)
                for (const obstacle of obstacles) {
                    if (isInView(obstacle)) {
                        ctx.fillStyle = obstacle.color;
                        ctx.fillRect(
                            obstacle.x - camera.x,
                            obstacle.y - camera.y,
                            obstacle.width,
                            obstacle.height
                        );
                    }
                }
                
                // Draw powerups (only those in view)
                for (const powerup of powerups) {
                    if (isInView(powerup)) {
                        // Draw glow
                        const glow = ctx.createRadialGradient(
                            powerup.x - camera.x,
                            powerup.y - camera.y,
                            0,
                            powerup.x - camera.x,
                            powerup.y - camera.y,
                            powerup.width * 2
                        );
                        
                        glow.addColorStop(0, powerup.color);
                        glow.addColorStop(1, 'rgba(0,0,0,0)');
                        
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(
                            powerup.x - camera.x,
                            powerup.y - camera.y,
                            powerup.width * 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Draw powerup
                        ctx.fillStyle = powerup.color;
                        ctx.beginPath();
                        ctx.arc(
                            powerup.x - camera.x,
                            powerup.y - camera.y,
                            powerup.width/2 * powerup.pulseSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Draw icon
                        ctx.fillStyle = 'white';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        let icon = '';
                        switch(powerup.type) {
                            case 'health': icon = '+'; break;
                            case 'weapon': icon = 'W'; break;
                            case 'speed': icon = 'S'; break;
                            case 'ammo': icon = 'A'; break;
                        }
                        
                        ctx.fillText(
                            icon,
                            powerup.x - camera.x,
                            powerup.y - camera.y
                        );
                    }
                }
                
                // Draw particles (only those in view)
                for (const particle of particles) {
                    const screenX = particle.x - camera.x;
                    const screenY = particle.y - camera.y;
                    
                    if (
                        screenX >= -particle.size && 
                        screenX <= canvas.width + particle.size &&
                        screenY >= -particle.size && 
                        screenY <= canvas.height + particle.size
                    ) {
                        ctx.globalAlpha = particle.lifetime / particle.maxLifetime;
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(
                            screenX,
                            screenY,
                            particle.size * (0.5 + 0.5 * (1 - particle.lifetime / particle.maxLifetime)),
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }
                
                // Draw bullets (only those in view)
                for (const bullet of bullets) {
                    const screenX = bullet.x - camera.x;
                    const screenY = bullet.y - camera.y;
                    
                    if (
                        screenX >= -bullet.width && 
                        screenX <= canvas.width + bullet.width &&
                        screenY >= -bullet.height && 
                        screenY <= canvas.height + bullet.height
                    ) {
                        if (bullet.isGrenade) {
                            // Draw grenade
                            ctx.fillStyle = bullet.color;
                            ctx.beginPath();
                            ctx.arc(
                                screenX,
                                screenY,
                                bullet.width / 2,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            // Draw timer indication
                            const timerRatio = bullet.timer / 30; // 30 is initial timer value
                            ctx.fillStyle = timerRatio > 0.5 ? 'yellow' : 'red';
                            ctx.beginPath();
                            ctx.arc(
                                screenX,
                                screenY,
                                bullet.width / 4,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        } else {
                            // Draw regular bullet
                            ctx.fillStyle = bullet.color;
                            ctx.beginPath();
                            ctx.arc(
                                screenX,
                                screenY,
                                bullet.width / 2,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            // Add bullet trail
                            ctx.strokeStyle = bullet.color;
                            ctx.lineWidth = bullet.width / 2;
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(
                                screenX - Math.cos(bullet.angle) * (bullet.speed * 2),
                                screenY - Math.sin(bullet.angle) * (bullet.speed * 2)
                            );
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    }
                }
                
                // Draw enemies (only those in view)
                for (const enemy of enemies) {
                    const screenX = enemy.x - camera.x;
                    const screenY = enemy.y - camera.y;
                    
                    if (
                        screenX >= -enemy.width && 
                        screenX <= canvas.width + enemy.width &&
                        screenY >= -enemy.height && 
                        screenY <= canvas.height + enemy.height
                    ) {
                        // Draw enemy body
                        ctx.fillStyle = enemy.color;
                        
                        if (enemy.type === 'normal') {
                            // Regular zombie (square)
                            ctx.fillRect(
                                screenX - enemy.width/2,
                                screenY - enemy.height/2,
                                enemy.width,
                                enemy.height
                            );
                            
                            // Face details
                            ctx.fillStyle = 'black';
                            ctx.fillRect(
                                screenX - enemy.width/4,
                                screenY - enemy.height/5,
                                enemy.width/5,
                                enemy.height/5
                            );
                            ctx.fillRect(
                                screenX + enemy.width/10,
                                screenY - enemy.height/5,
                                enemy.width/5,
                                enemy.height/5
                            );
                        } else if (enemy.type === 'fast') {
                            // Fast zombie (triangle)
                            ctx.beginPath();
                            ctx.moveTo(
                                screenX,
                                screenY - enemy.height/2
                            );
                            ctx.lineTo(
                                screenX + enemy.width/2,
                                screenY + enemy.height/2
                            );
                            ctx.lineTo(
                                screenX - enemy.width/2,
                                screenY + enemy.height/2
                            );
                            ctx.closePath();
                            ctx.fill();
                            
                            // Eyes
                            ctx.fillStyle = 'black';
                            ctx.fillRect(
                                screenX - enemy.width/4,
                                screenY - enemy.height/10,
                                enemy.width/5,
                                enemy.height/5
                            );
                            ctx.fillRect(
                                screenX + enemy.width/10,
                                screenY - enemy.height/10,
                                enemy.width/5,
                                enemy.height/5
                            );
                        } else if (enemy.type === 'tank') {
                            // Tank zombie (circle)
                            ctx.beginPath();
                            ctx.arc(
                                screenX,
                                screenY,
                                enemy.width/2,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            // Face details
                            ctx.fillStyle = 'black';
                            ctx.beginPath();
                            ctx.arc(
                                screenX - enemy.width/5,
                                screenY - enemy.height/5,
                                enemy.width/8,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            ctx.beginPath();
                            ctx.arc(
                                screenX + enemy.width/5,
                                screenY - enemy.height/5,
                                enemy.width/8,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        } else if (enemy.type === 'boss') {
                            // Boss zombie (pentagon)
                            ctx.beginPath();
                            for (let i = 0; i < 5; i++) {
                                const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                                const x = screenX + Math.cos(angle) * enemy.width/2;
                                const y = screenY + Math.sin(angle) * enemy.height/2;
                                
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            ctx.closePath();
                            ctx.fill();
                            
                            // Draw evil eyes
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(
                                screenX - enemy.width/4,
                                screenY - enemy.height/6,
                                enemy.width/8,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            ctx.beginPath();
                            ctx.arc(
                                screenX + enemy.width/4,
                                screenY - enemy.height/6,
                                enemy.width/8,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            ctx.fillStyle = 'red';
                            ctx.beginPath();
                            ctx.arc(
                                screenX - enemy.width/4,
                                screenY - enemy.height/6,
                                enemy.width/16,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            ctx.beginPath();
                            ctx.arc(
                                screenX + enemy.width/4,
                                screenY - enemy.height/6,
                                enemy.width/16,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            // Aura for boss
                            ctx.globalAlpha = 0.3;
                            const gradient = ctx.createRadialGradient(
                                screenX, screenY, enemy.width/2,
                                screenX, screenY, enemy.width
                            );
                            gradient.addColorStop(0, enemy.color);
                            gradient.addColorStop(1, 'rgba(0,0,0,0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(
                                screenX, screenY, enemy.width,
                                0, Math.PI * 2
                            );
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        
                        // Health bar
                        const healthPercent = enemy.health / enemy.maxHealth;
                        const barWidth = enemy.width;
                        const barHeight = 4;
                        
                        ctx.fillStyle = '#555';
                        ctx.fillRect(
                            screenX - barWidth/2,
                            screenY - enemy.height/2 - barHeight - 2,
                            barWidth,
                            barHeight
                        );
                        
                        ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : (healthPercent > 0.2 ? '#f1c40f' : '#e74c3c');
                        ctx.fillRect(
                            screenX - barWidth/2,
                            screenY - enemy.height/2 - barHeight - 2,
                            barWidth * healthPercent,
                            barHeight
                        );
                        
                        // Show boss health as text
                        if (enemy.type === 'boss') {
                            ctx.fillStyle = 'white';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                Math.ceil(enemy.health),
                                screenX,
                                screenY - enemy.height/2 - barHeight - 5
                            );
                        }
                    }
                }
                
                // Draw player
                ctx.fillStyle = '#3498db';
                ctx.fillRect(
                    player.x - player.width/2 - camera.x,
                    player.y - player.height/2 - camera.y,
                    player.width,
                    player.height
                );
                
                // Draw player direction (towards mouse)
                const angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
                ctx.fillStyle = '#2980b9';
                
                // Draw weapon based on current weapon type
                if (player.weapon === 'Pistol') {
                    // Simple line for pistol
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.moveTo(
                        player.x - camera.x,
                        player.y - camera.y
                    );
                    ctx.lineTo(
                        player.x + Math.cos(angle) * player.width * 0.8 - camera.x,
                        player.y + Math.sin(angle) * player.width * 0.8 - camera.y
                    );
                    ctx.stroke();
                } else if (player.weapon === 'Shotgun') {
                    // Thicker, longer line for shotgun
                    ctx.lineWidth = 5;
                    ctx.strokeStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.moveTo(
                        player.x - camera.x,
                        player.y - camera.y
                    );
                    ctx.lineTo(
                        player.x + Math.cos(angle) * player.width - camera.x,
                        player.y + Math.sin(angle) * player.width - camera.y
                    );
                    ctx.stroke();
                } else if (player.weapon === 'MachineGun') {
                    // Box-like shape for machine gun
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.moveTo(
                        player.x - camera.x,
                        player.y - camera.y
                    );
                    ctx.lineTo(
                        player.x + Math.cos(angle) * player.width * 0.9 - camera.x,
                        player.y + Math.sin(angle) * player.width * 0.9 - camera.y
                    );
                    ctx.stroke();
                    
                    // Add a magazine
                    const perpAngle = angle + Math.PI/2;
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(
                        player.x + Math.cos(angle) * player.width * 0.5 + Math.cos(perpAngle) * 5 - camera.x - 3,
                        player.y + Math.sin(angle) * player.width * 0.5 + Math.sin(perpAngle) * 5 - camera.y - 3,
                        6,
                        6
                    );
                } else if (player.weapon === 'GrenadeLauncher') {
                    // Thick, shorter line for grenade launcher
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.moveTo(
                        player.x - camera.x,
                        player.y - camera.y
                    );
                    ctx.lineTo(
                        player.x + Math.cos(angle) * player.width * 0.7 - camera.x,
                        player.y + Math.sin(angle) * player.width * 0.7 - camera.y
                    );
                    ctx.stroke();
                }
                
                // Draw health bar
                const healthPercent = player.health / player.maxHealth;
                ctx.fillStyle = '#555';
                ctx.fillRect(
                    player.x - player.width/2 - camera.x,
                    player.y - player.height/2 - 10 - camera.y,
                    player.width,
                    5
                );
                
                ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : (healthPercent > 0.2 ? '#f1c40f' : '#e74c3c');
                ctx.fillRect(
                    player.x - player.width/2 - camera.x,
                    player.y - player.height/2 - 10 - camera.y,
                    player.width * healthPercent,
                    5
                );
                
                // Draw minimap
                drawMinimap();
            }
            
            // Draw minimap
            function drawMinimap() {
                // Clear minimap
                minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
                
                // Fill background
                minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
                
                // Scale factors to fit world into minimap
                const scaleX = minimapCanvas.width / CONFIG.WORLD_WIDTH;
                const scaleY = minimapCanvas.height / CONFIG.WORLD_HEIGHT;
                
                // Draw obstacles on minimap
                minimapCtx.fillStyle = '#777';
                for (const obstacle of obstacles) {
                    minimapCtx.fillRect(
                        obstacle.x * scaleX,
                        obstacle.y * scaleY,
                        obstacle.width * scaleX,
                        obstacle.height * scaleY
                    );
                }
                
                // Draw enemies on minimap
                for (const enemy of enemies) {
                    minimapCtx.fillStyle = enemy.color;
                    minimapCtx.fillRect(
                        (enemy.x - enemy.width/2) * scaleX,
                        (enemy.y - enemy.height/2) * scaleY,
                        enemy.width * scaleX,
                        enemy.height * scaleY
                    );
                }
                
                // Draw powerups on minimap
                for (const powerup of powerups) {
                    minimapCtx.fillStyle = powerup.color;
                    minimapCtx.fillRect(
                        (powerup.x - powerup.width/2) * scaleX,
                        (powerup.y - powerup.height/2) * scaleY,
                        powerup.width * scaleX,
                        powerup.height * scaleY
                    );
                }
                
                // Draw player on minimap
                minimapCtx.fillStyle = '#3498db';
                minimapCtx.fillRect(
                    (player.x - player.width/2) * scaleX,
                    (player.y - player.height/2) * scaleY,
                    player.width * scaleX,
                    player.height * scaleY
                );
                
                // Draw camera viewport on minimap
                minimapCtx.strokeStyle = 'white';
                minimapCtx.lineWidth = 1;
                minimapCtx.strokeRect(
                    camera.x * scaleX,
                    camera.y * scaleY,
                    camera.width * scaleX,
                    camera.height * scaleY
                );
            }
            
            // Game loop flag
            let isGameLoopRunning = false;
            
            // Game loop
            function gameLoop(timestamp) {
                // Calculate delta time
                deltaTime = timestamp - lastFrameTime;
                lastFrameTime = timestamp;
                
                // Cap delta time to avoid huge jumps
                if (deltaTime > 1000 / 30) {
                    deltaTime = 1000 / 30;
                }
                
                // Convert to seconds
                const dt = deltaTime / 1000;
                
                update(dt);
                render();
                
                if (gameRunning) {
                    requestAnimationFrame(gameLoop);
                } else {
                    isGameLoopRunning = false;
                }
            }
            
            // Initialize
            function init() {
                // Get canvas and context
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');
                
                // Get minimap canvas and context
                minimapCanvas = document.getElementById('minimapCanvas');
                minimapCtx = minimapCanvas.getContext('2d');
                
                // Set up event listeners
                setupEventListeners();
                
                // Update camera dimensions
                camera.width = canvas.width;
                camera.height = canvas.height;
                
                // Check for saved game
                if (saveSystem.hasSave()) {
                    document.getElementById('continue-button-container').style.display = 'block';
                }
                
                // Update HUD
                updateHUD();
            }
            
            // Set up event listeners
            function setupEventListeners() {
                document.getElementById('start-button').addEventListener('click', initGame);
                document.getElementById('restart-button').addEventListener('click', initGame);
                document.getElementById('continue-button').addEventListener('click', continueGame);
                
                window.addEventListener('keydown', function(e) {
                    // Prevent default behavior for game control keys
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', 'W', 'A', 'S', 'D'].includes(e.key)) {
                        e.preventDefault();
                    }
                    keys[e.key] = true;
                    
                    // Toggle pause with Escape or P key
                    if ((e.key === 'Escape' || e.key === 'p' || e.key === 'P') && gameRunning) {
                        gamePaused = !gamePaused;
                    }
                    
                    // Switch weapons with number keys
                    if (e.key === '1') {
                        player.weapon = 'Pistol';
                        player.ammo = Infinity;
                        updateHUD();
                    } else if (e.key === '2' && currentWave >= 2) {
                        if (player.weapon !== 'Shotgun') {
                            player.weapon = 'Shotgun';
                            player.ammo = WEAPONS.Shotgun.ammo;
                            updateHUD();
                        }
                    } else if (e.key === '3' && currentWave >= 3) {
                        if (player.weapon !== 'MachineGun') {
                            player.weapon = 'MachineGun';
                            player.ammo = WEAPONS.MachineGun.ammo;
                            updateHUD();
                        }
                    } else if (e.key === '4' && currentWave >= 4) {
                        if (player.weapon !== 'GrenadeLauncher') {
                            player.weapon = 'GrenadeLauncher';
                            player.ammo = WEAPONS.GrenadeLauncher.ammo;
                            updateHUD();
                        }
                    }
                });
                
                window.addEventListener('keyup', function(e) {
                    keys[e.key] = false;
                });
                
                canvas.addEventListener('mousemove', function(e) {
                    const rect = canvas.getBoundingClientRect();
                    mouseX = e.clientX - rect.left;
                    mouseY = e.clientY - rect.top;
                });
                
                canvas.addEventListener('mousedown', function(e) {
                    if (e.button === 0) { // Left mouse button
                        shooting = true;
                    }
                });
                
                canvas.addEventListener('mouseup', function(e) {
                    if (e.button === 0) {
                        shooting = false;
                    }
                });
                
                // Prevent context menu on right-click
                canvas.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                });
            }
            
            // Public API
            return {
                init: init
            };
        })();
        
        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            BoxheadGame.init();
        });
    </script>
</body>
</html>
